{
	"Common PSCmdlet class": {
		"prefix": "ps-cmdlet-common",
		"body": [
            "[Cmdlet(VerbsCommon.${1|Add,Clear,Close,Copy,Enter,Exit,Find,Format,Get,Hide,Join,Lock,Move,New,Open,Optimize,Push,Pop,Redo,Remove,Rename,Reset,Resize,Search,Select,Set,Show,Skip,Split,Step,Switch,Undo,Unlock,Watch|}, \"${2:Noun}\")]",
            "public class $1_$2 : PSCmdlet",
            "{",
            "    $0",
            "",
            "    // protected override void BeginProcessing()",
            "    // {",
            "    // }",
            "",
            "    protected override void ProcessRecord()",
            "    {",
            "    }",
            "",
            "    // protected override void EndProcessing()",
            "    // {",
            "    // }",
            "}"
		],
        "description": "System.Management.Automation.PSCmdlet class using verb from System.Management.Automation.VerbsCommon."
	},
	"Communications PSCmdlet class": {
		"prefix": "ps-cmdlet-communications",
		"body": [
            "[Cmdlet(VerbsCommunications.${1|Connect,Disconnect,Read,Receive,Send,Write|}, \"${2:Noun}\")]",
            "public class $1_$2 : PSCmdlet",
            "{",
            "    $0",
            "",
            "    // protected override void BeginProcessing()",
            "    // {",
            "    // }",
            "",
            "    protected override void ProcessRecord()",
            "    {",
            "    }",
            "",
            "    // protected override void EndProcessing()",
            "    // {",
            "    // }",
            "}"
        ],
        "description": "System.Management.Automation.PSCmdlet class using verb from System.Management.Automation.VerbsCommunications."
	},
	"Data PSCmdlet class": {
		"prefix": "ps-cmdlet-data",
		"body": [
            "[Cmdlet(VerbsData.${1|Backup,Checkpoint,Compare,Compress,Convert,ConvertFrom,ConvertTo,Dismount,Edit,Expand,Export,Group,Import,Initialize,Limit,Merge,Mount,Out,Publish,Restore,Save,Sync,Unpublish,Update|}, \"${2:Noun}\")]",
            "public class $1_$2 : PSCmdlet",
            "{",
            "    $0",
            "",
            "    // protected override void BeginProcessing()",
            "    // {",
            "    // }",
            "",
            "    protected override void ProcessRecord()",
            "    {",
            "    }",
            "",
            "    // protected override void EndProcessing()",
            "    // {",
            "    // }",
            "}"
        ],
        "description": "System.Management.Automation.PSCmdlet class using verb from System.Management.Automation.VerbsData."
	},
	"Diagnostic PSCmdlet class": {
		"prefix": "ps-cmdlet-diagnostic",
		"body": [
            "[Cmdlet(VerbsDiagnostic.${1|Debug,Measure,Ping,Repair,Resolve,Test,Trace|}, \"${2:Noun}\")]",
            "public class $1_$2 : PSCmdlet",
            "{",
            "    $0",
            "",
            "    // protected override void BeginProcessing()",
            "    // {",
            "    // }",
            "",
            "    protected override void ProcessRecord()",
            "    {",
            "    }",
            "",
            "    // protected override void EndProcessing()",
            "    // {",
            "    // }",
            "}"
        ],
        "description": "System.Management.Automation.PSCmdlet class using verb from System.Management.Automation.VerbsDiagnostic."
	},
	"Lifecycle PSCmdlet class": {
		"prefix": "ps-cmdlet-lifecycle",
		"body": [
            "[Cmdlet(VerbsLifecycle.${1|Approve,Assert,Build,Complete,Confirm,Deny,Deploy,Disable,Enable,Install,Invoke,Register,Request,Restart,Resume,Start,Stop,Submit,Suspend,Uninstall,Unregister,Wait|}, \"${2:Noun}\")]",
            "public class $1_$2 : PSCmdlet",
            "{",
            "    $0",
            "",
            "    // protected override void BeginProcessing()",
            "    // {",
            "    // }",
            "",
            "    protected override void ProcessRecord()",
            "    {",
            "    }",
            "",
            "    // protected override void EndProcessing()",
            "    // {",
            "    // }",
            "}"
        ],
        "description": "PSCmdlet class using verb from System.Management.Automation.VerbsLifecycle."
	},
	"Security PSCmdlet class": {
		"prefix": "ps-cmdlet-security",
		"body": [
            "[Cmdlet(VerbsSecurity.${1|Block,Grant,Protect,Revoke,Unblock,Unprotect|}, \"${2:Noun}\")]",
            "public class $1_$2 : PSCmdlet",
            "{",
            "    $0",
            "",
            "    // protected override void BeginProcessing()",
            "    // {",
            "    // }",
            "",
            "    protected override void ProcessRecord()",
            "    {",
            "    }",
            "",
            "    // protected override void EndProcessing()",
            "    // {",
            "    // }",
            "}"
        ],
        "description": "System.Management.Automation.PSCmdlet class using verb from System.Management.Automation.VerbsSecurity."
	},
	"Use PSCmdlet class": {
		"prefix": "ps-cmdlet-use",
		"body": [
            "[Cmdlet(VerbsOther.Use, \"${1:Noun}\")]",
            "public class Use_$1 : PSCmdlet",
            "{",
            "    $0",
            "",
            "    // protected override void BeginProcessing()",
            "    // {",
            "    // }",
            "",
            "    protected override void ProcessRecord()",
            "    {",
            "    }",
            "",
            "    // protected override void EndProcessing()",
            "    // {",
            "    // }",
            "}"
        ],
        "description": "System.Management.Automation.PSCmdlet class using the System.Management.Automation.VerbsOther.Use verb."
	},
	"PSCmdletParameterSet": {
		"prefix": "ps-parameterset",
		"body": [
            "public const string ParameterSetName_${1:SetName} = \"$1\";",
            "",
            "[Parameter(Mandatory = true$0, ParameterSetName = ParameterSetName_$1,",
            "    HelpMessage = \"${2:Help message.}\")]",
            "[ValidateNotNullOrEmpty()]",
            "public ${3:ParameterType[]} ${4:ParameterName} { get; set; }${5: = null!;}"
        ],
        "description": "PowerShell Cmdlet parameter property for new Parameter Set."
	},
	"PSCmdletParameter": {
		"prefix": "ps-parameter",
		"body": [
            "[Parameter(Mandatory = true$0, HelpMessage = \"${1:Help message.}\")]",
            "[ValidateNotNullOrEmpty()]",
            "public ${2:ParameterType[]} ${3:ParameterName} { get; set; }${4: = null!;}"
        ],
        "description": "PowerShell Cmdlet parameter property."
	},
	"PSCmdletPathParameter:Wc/Literal": {
		"prefix": "ps-parameter-wcpath-literal",
		"body": [
            "public const string ParameterSetName_${1:WcPath} = \"$1\";",
            "",
            "[Parameter(Mandatory = true, Position = 0$0, ValueFromPipeline = true, ValueFromPipelineByPropertyName = true, ParameterSetName = ParameterSetName_$1,",
            "    HelpMessage = \"${2:Path to one or more locations.}\")]",
            "[ValidateNotNullOrEmpty()]",
            "[SupportsWildcards()]",
            "public string[] ${3:Path} { get; set; } = null!;",
            "",
            "public const string ParameterSetName_${4:LiteralPath} = \"$4\";",
            "",
            "[Parameter(Mandatory = true, ValueFromPipelineByPropertyName = true, ParameterSetName = ParameterSetName_$4,",
            "    HelpMessage = \"${5:Literal path to one or more locations.}\")]",
            "[Alias(\"PSPath\")]",
            "[ValidateNotNullOrEmpty()]",
            "public string[] ${6:LiteralPath} { get; set; } = null!;"
        ],
        "description": "PowerShell Cmdlet parameter properties for both literal paths and paths that support wildcards."
	},
	"PSCmdletPathParameter:Wc": {
		"prefix": "ps-parameter-wcpath",
		"body": [
            "[Parameter(Mandatory = true, Position = 0$0, ValueFromPipeline = true, ValueFromPipelineByPropertyName = true,",
            "    HelpMessage = \"${1:Path to one or more locations.}\")]"
            "[ValidateNotNullOrEmpty()]",
            "[SupportsWildcards()]",
            "public string[] ${2:Path} { get; set; } = null!;"
        ],
        "description": "PowerShell Cmdlet parameter property for paths that support wildcards."
	},
	"PSCmdletPathParameter:Literal": {
		"prefix": "ps-parameter-literalpath",
		"body": [
            "[Parameter(Mandatory = true, ValueFromPipelineByPropertyName = true,$0",
            "    HelpMessage = \"${1:Literal path to one or more locations.}\")]",
            "[Alias(\"PSPath\")]",
            "[ValidateNotNullOrEmpty()]",
            "public string[] ${2:LiteralPath} { get; set; } = null!;"
        ],
        "description": "PowerShell Cmdlet parameter property for literal paths."
	},
    "PsCmdletResolvePath:Wc/Literal": {
        "prefix": "ps-resolve-path-wc-literal",
        "body": [
            "if (ParameterSetName == ParameterSetName_${1:LiteralPath})",
            "{",
            "    foreach (string path in ${2:LiteralPath})",
            "    {",
            "        if (!SessionState.Path.IsValid(path))",
            "        {",
            "            WriteError(CreateArgumentErrorRecord($\"Path string {path} is not valid.\", ErrorId_PathIsInvalid, path, nameof($2)));",
            "            continue;",
            "        }",
            "        if (InvokeProvider.Item.Exists(path))",
            "        {",
            "            string providerPath = SessionState.Path.GetUnresolvedProviderPathFromPSPath(path);",
            "            if (providerPath is not null)",
            "            {",
            "                // Process providerPath",
            "                continue;",
            "            }",
            "        }",
            "        WriteError(CreateItemNotFoundErrorRecord($\"Item referenced by path {path} was not found.\", ErrorId_ItemNotFound, path, nameof($2)));",
            "    }",
            "}",
            "else",
            "{",
            "    foreach (string path in ${3:Path})",
            "    {",
            "        if (!SessionState.Path.IsValid(path))",
            "        {",
            "            WriteError(CreateArgumentErrorRecord($\"Path string {path} is not valid.\", ErrorId_PathIsInvalid, path, nameof($3)));",
            "            continue;",
            "        }",
            "        if (InvokeProvider.Item.Exists(path))",
            "        {",
            "            Collection<string> providerPaths =  SessionState.Path.GetResolvedProviderPathFromPSPath(path, out ProviderInfo provider);",
            "            if (providerPaths is not null && providerPaths.Count > 0)",
            "            {",
            "                // Process providerPaths",
            "                continue;",
            "            }",
            "        }",
            "        WriteError(CreateItemNotFoundErrorRecord($\"Item referenced by path {path} was not found.\", ErrorId_ItemNotFound, path, nameof($3)));",
            "    }",
            "}"
        ],
        "description": "Code for resolving literal and wildcard paths for PowerShell Cmdlet parameter properties."
    },
    "PsCmdletResolvePath:Wc": {
        "prefix": "ps-resolve-path-wc",
        "body": [
            "foreach (string path in ${1:Path})",
            "{",
            "    if (!SessionState.Path.IsValid(path))",
            "    {",
            "        WriteError(CreateArgumentErrorRecord($\"Path string {path} is not valid.\", ErrorId_PathIsInvalid, path, nameof($1)));",
            "        continue;",
            "    }",
            "    if (InvokeProvider.Item.Exists(path))",
            "    {",
            "        Collection<string> providerPaths =  SessionState.Path.GetResolvedProviderPathFromPSPath(path, out ProviderInfo provider);",
            "        if (providerPaths is not null && providerPaths.Count > 0)",
            "        {",
            "            // Process providerPaths",
            "            continue;",
            "        }",
            "    }",
            "    WriteError(CreateItemNotFoundErrorRecord($\"Item referenced by path {path} was not found.\", ErrorId_ItemNotFound, path, nameof($1)));",
            "}",
        ],
        "description": "Code for resolving literal and wildcard paths for PowerShell Cmdlet parameter properties."
    },
    "PsCmdletResolvePath:Literal": {
        "prefix": "ps-resolve-path-literal",
        "body": [
            "foreach (string path in ${1:LiteralPath})",
            "{",
            "    if (!SessionState.Path.IsValid(path))",
            "    {",
            "        WriteError(CreateArgumentErrorRecord($\"Path string {path} is not valid.\", ErrorId_PathIsInvalid, path, nameof($1)));",
            "        continue;",
            "    }",
            "    if (InvokeProvider.Item.Exists(path))",
            "    {",
            "        string providerPath = SessionState.Path.GetUnresolvedProviderPathFromPSPath(path);",
            "        if (providerPath is not null)",
            "        {",
            "            // Process providerPath",
            "            continue;",
            "        }",
            "    }",
            "    WriteError(CreateItemNotFoundErrorRecord($\"Item referenced by path {path} was not found.\", ErrorId_ItemNotFound, path, nameof($1)));",
            "}",
        ],
        "description": "Code for resolving literal and wildcard paths for PowerShell Cmdlet parameter properties."
    }
}